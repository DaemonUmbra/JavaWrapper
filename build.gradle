plugins {
	id 'org.echocat.golang' version '0.1.13'
}

version = project.version
group 'github.com/MinecraftForge/JavaWrapper'
golang {
	platforms = System.getProperty("platforms", project.platforms)

	// packageName = project.name
	dependencies {
		build 'github.com/fatih/color'
		build 'github.com/ulikunitz/xz/lzma'
		build 'github.com/kardianos/osext'

	//Hack to fix the build
	deleteAllCachedDependenciesOnClean = true
	}

	build {
		excludes = [
			'.git/**',
			'build.gradle',
			'build/**',
			'.gradle/**',
			'gradle/**'
		]

	useTemporaryGopath = true
	//Manully change the output directory it will out b
	outputFilenamePattern = "../out/$project.binname-v$project.version-%{platform}%{extension}"
	}
}

if (System.getenv('INSTALLER_VERSION')) {
	project.ext.fversion = "${System.getenv('INSTALLER_VERSION')}"
	} else {
	project.ext.fversion = "1.11-13.19.1.2199"
}

task downloadForge(type: Download) {
	src = "http://files.minecraftforge.net/maven/net/minecraftforge/forge/${project.ext.fversion}/forge-${project.ext.fversion}-installer.jar"
	hash = 'sha1'
}

def baseInclude = "${project.binname}-v${project.version}"
task pkgWindows(type: Zip) {
	dependsOn baseBuild
	baseName = 'Windows'
	version = project.version
	destinationDir file("${buildDir}/pkg")
	from "$buildDir/out/"
	include '*.exe'
}

task pkgOsx(type: Tar) {
	 dependsOn baseBuild
	 baseName = 'Osx'
	 version = project.version
	 extension = 'tar.gz'
	 destinationDir file("${buildDir}/pkg")
	 compression = Compression.GZIP
	 from "$buildDir/out/"
	 include "$baseInclude-darwin-amd64"
}

task pkgLinux(type: Tar) {
	 dependsOn baseBuild
	 baseName = 'Linux'
	 version = project.version
	 extension = 'tar.gz'
	 destinationDir file("${buildDir}/pkg")
	 compression = Compression.GZIP
	 from "$buildDir/out/"
	 include "$baseInclude-linux-386"
}

task installerWin(type: Installer){
	 dependsOn pkgWindows
	 from zipTree(pkgWindows.outputs.files.singleFile)
	 into file("${buildDir}/pkg/")
	 rename "forge-installer-${project.ext.fversion}-win.exe"
}

task installerOsx(type: Installer) {
	 dependsOn pkgOsx
	 from tarTree(resources.gzip(pkgOsx.outputs.files.singleFile))
	 into file("${buildDir}/pkg/")
	 rename "forge-installer-${project.ext.fversion}-osx"
}

task installerLinux(type: Installer) {
	dependsOn pkgLinux
	from tarTree(resources.gzip(pkgLinux.outputs.files.singleFile))
	into file("${buildDir}/pkg/")
	rename "forge-installer-${project.ext.fversion}-linux"
}


task pkgWindowsInstaller(type: Zip) {
	dependsOn installerWin
	baseName = 'Windows-Installer'
	version = project.ext.fversion
	destinationDir file("${buildDir}/pkginstaller")
	from "$buildDir/pkg/"
	include "forge-installer-${project.ext.fversion}-win.exe"

}

task pkgOsxInstaller(type: Tar) {
	 dependsOn installerOsx
	 baseName = 'Osx-Installer'
	 version = project.ext.fversion
	 extension = 'tar.gz'
	 destinationDir file("${buildDir}/pkginstaller")
	 compression = Compression.GZIP
	 from "$buildDir/pkg/"
	 include "forge-installer-${project.ext.fversion}-osx"

}

task pkgLinuxInstaller(type: Tar) {
	 dependsOn installerLinux
	 baseName = 'Linux-Installer'
	 version = project.ext.fversion
	 extension = 'tar.gz'
	 destinationDir file("${buildDir}/pkginstaller")
	 compression = Compression.GZIP
	 from "$buildDir/pkg/"
	 include "forge-installer-${project.ext.fversion}-linux"
}

task pkgNormal() {
	dependsOn pkgLinux, pkgOsx, pkgWindows
	description 'Creates package for each platform'
}

task installer {
	dependsOn pkgLinuxInstaller, pkgOsxInstaller, pkgWindowsInstaller
	description 'Creates the installers for each platform'
}

task wrapper(type: Wrapper) {
	gradleVersion = '3.3'
}

class Installer extends Copy {

	def filename
	{
		outputs.upToDateWhen {false}
		dependsOn project.tasks.downloadForge
		doLast {
			// append to the end of the binary
			def file = new File(this.outputs.files.singleFile, filename)
			file << project.tasks.downloadForge.outputs.files.singleFile.bytes
		}
	}
	
	def rename(str) {
		rename('.*', str)
		filename = str
	}
}

class Download extends DefaultTask {

	@Input
	def src
	@Input
	def hash
	@Input
	def dest = temporaryDir
	@OutputFile
	def outputFile

	def setSrc(src) {
		this.src = src
		this.outputFile = new File(dest, fileName)
	}
	
	def setDest(File file) {
		this.dest = file
		this.outputFile = new File(dest, fileName)
	}

	def setHash(hash) {
		this.hash = hash
	}
	
	def getFileName() {
		return getName(this.src)
	}

	@TaskAction
	public void downloadFile() {
		def file = this.outputFile
		file.bytes = new URL(src).bytes
		
		if (hash) {
			def remoteHash = new URL(src + '.' + hash).text

			def digest = java.security.MessageDigest.getInstance(hash)
			file.eachByte(4095) {buffer, length ->
				digest.update(buffer, 0, length)
			}
			def localHash = new BigInteger(1, digest.digest()).toString(16).padLeft(32, '0')
			
			if (localHash != remoteHash) {
				throw new GradleException("File hash failed. Expected $remoteHash, but got $localHash")
			}
		}
		
	}

	private static String getName(String filename) {
		if (filename == null) {
			return null;
		}
		def lastUnixPos = filename.lastIndexOf('/');
		def lastWindowsPos = filename.lastIndexOf('\\');
		def index = Math.max(lastUnixPos, lastWindowsPos);

		return filename.substring(index + 1);
	}
}
